/*
  AUTHORS : 
    Vincenzi Fabio, fabio.vincenzi2@studio.unibo.it
    Iorio Matteo, matteo.iorio2@studio.unibo.it
    Rapolla Luca, luca.rapolla@studio.unibo.it
  DESCRIPTION : 
    First task, Catch The Led Pattern
*/


#define EI_ARDUINO_INTERRUPTED_PIN // to enable pin states functionality 
#include <EnableInterrupt.h>
#include <Arduino.h>
#include <avr/power.h>
#include <avr/sleep.h>
#include <TimerOne.h>

#include "Status.h"
#include "GameController.cpp"

/*HARDWARE DATAS*/
#define BOUNCE_DURATION 20
#define TEN_SECONDS_SLEEP 10*pow(10, 6)
#define TEN_SECONDS_DELAY 10*pow(10, 3)
#define NLEDS 4

#define SEPARATION_LINE Serial.println("----------------------------------------------------------");
#define PENALTY_LINE Serial.println("_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-");


/*---- LEDS -----*/
#define PIN_LED_1_GREEN 13
#define PIN_LED_2_GREEN 12
#define PIN_LED_3_GREEN 11
#define PIN_LED_4_GREEN 10
#define PIN_RED_LED 6
#define ENABLE_INT_IN_PIN 2

/*---- POTENTIOMETER -----*/
#define POTENTIOMETER_INPUT_PIN A0;
/*---- BUTTONS -----*/
#define PIN_BUTTON_1 5
#define PIN_BUTTON_2 4
#define PIN_BUTTON_3 3
#define PIN_BUTTON_4 2
/*INFORMATION FOR THE HANDLERS*/
#define FIRST_BUTTON 1
#define SECOND_BUTTON 2
#define THIRD_BUTTON 3
#define FOURTH_BUTTON 4

int brightness;
int fadeAmount;
int currIntensity;
volatile int timer_select_leds = 0, timer_show_pattern = 0, timer_deep_sleep = 0, bounceTime = 0;
GameController *controller;

/// @brief this method is used in the selection of the leds that match the bot pattern. 
/// It is called by a Timer interrupt. We use "timer_select_leds", because the Timer call this function immediately but we want 
/// to call this function after the timer dispatch. 
void selectLeds(){
  timer_select_leds++;
  if(timer_select_leds == 2){
    controller->phaseSelectLeds();
    Serial.println("===> The time is over");
    Timer1.detachInterrupt();
    timer_select_leds = 0;
  }
}
/// @brief This method is used for shutting off all the leds in the breadboard
void allLedsOff(){
    digitalWrite(PIN_LED_1_GREEN, LOW);
    digitalWrite(PIN_LED_2_GREEN, LOW);
    digitalWrite(PIN_LED_3_GREEN, LOW);
    digitalWrite(PIN_LED_4_GREEN, LOW);
    analogWrite(PIN_RED_LED, 0);
    delay(10);
}
/// @brief This method is used to turn on all the bot's leds, in order to show at the User the bot's pattern
void updateLeds(){
  bool* leds = controller->getBotLeds();
  int led;
  for(int i = 0; i < NLEDS; i++){
      switch (i)
      {
        case 0:
          led = PIN_LED_1_GREEN;
          break;
        case 1 :
          led = PIN_LED_2_GREEN;
          break;
        case 2 :
          led = PIN_LED_3_GREEN;
          break;
        case 3 : 
          led = PIN_LED_4_GREEN;
          break;
        default:
          break;
      }
    digitalWrite(led, leds[i]?HIGH:LOW);
  }
}
/// @brief This method is called when a button is pressed during the deep sleep status. With this method we wake up the Arduino, returning to the
/// blinking phase of the Red Led.
void wakeUp(){
  if(controller->getStatus() == DEEP_SLEEP and abs(millis() - bounceTime) > BOUNCE_DURATION){
    controller->phaseWakeUp();
    bounceTime = millis();
    Serial.println("==> Just wake up...");
    Serial.flush();
    timer_deep_sleep = 0;
    sleep_disable();
    power_all_enable();
  }
}
/// @brief This method gives the opportunity to the User for recreate the bot's pattern without having penalties
void gameScore(){
    controller->phaseGameScore();
    Timer1.detachInterrupt();
    allLedsOff();
    Timer1.initialize(controller->getTimerT3() * pow(10,6));
    Timer1.attachInterrupt(selectLeds);
    Serial.println("==> Recreate the pattern....");
    controller->phaseRecreatePattern();
}
/// @brief This method the first thing that does is create the pattern and show it to the User and when the Timer call the interrupt
/// all the bot's leds pattern are shutted off
void showPattern(){
  timer_show_pattern++;
  if(timer_show_pattern == 2){
    controller->phaseShowPattern();
    Timer1.detachInterrupt();
    allLedsOff();
    /*Show all the bot led pattern*/
    Timer1.initialize();
    Timer1.attachInterrupt(gameScore);
    timer_show_pattern=0;
  }else{
    controller->botGenerateSequence();
    updateLeds();
  }
}
/// @brief This method is called when the User commit a penalty during the game
void showPenalty(){
    controller->phasePenalty();
}
/// @brief t
void continueGame(){
    controller->userResetAllPositions();
    Serial.println("--> The game is starting..");
    Serial.flush();
    allLedsOff();//Shutting all leds off
    Timer1.detachInterrupt(); // Detach the deep_sleep interrupt
    controller->timerShowPattern();
    /*After T1 time, We show the pattern generated by the Bots*/
    Timer1.initialize(controller->getTimerT2()*pow(10,6));
    Timer1.attachInterrupt(showPattern);
}
/// @brief This method is clled when the B1 Button is pressed, during the blinking phase of the red led. This method 
/// Let the game starts
void startGame(){
    //selecting the difficulty from the potentiometer
    controller->selectDifficulty(analogRead(A0));
    /*Plot on the serial line*/
    Serial.print("-> Difficulty selected : "); 
    Serial.println(controller->getSelectedDifficulty());
    Serial.flush();
    allLedsOff();
    controller->phaseStartGame();
    controller->timerLedsOff();
    //All the leds are turned of for T1 seconds
    Timer1.initialize(controller->getTimerT1()*pow(10, 6));
    Timer1.attachInterrupt(continueGame);
}
/// @brief This method handles the deep_sleep interrupt. It is called after 10 seconds from the first blinking phase
void deepSleep(){
  timer_deep_sleep++;
  if(timer_deep_sleep == 2){
      if(controller->getStatus() == INPUT_WAIT){
        Serial.println("=> Going to sleep");
        controller->phaseDeepSleep();
        allLedsOff();
        set_sleep_mode(SLEEP_MODE_IDLE);
        sleep_enable();    
    }
  }
}
/// @brief This method turns on a single led in the breadboard
/// @param led which led we have to swtich on
void ledON(int led){
  switch(led){
    case 1:
      digitalWrite(PIN_LED_1_GREEN, HIGH);
    break;
    case 2:
      digitalWrite(PIN_LED_2_GREEN, HIGH);
    break;
    case 3:
      digitalWrite(PIN_LED_3_GREEN, HIGH);
    break;
    case 4:
      digitalWrite(PIN_LED_4_GREEN, HIGH);
    break;
  }
}
/// @brief This method manage the various handlers of a single button
/// @param button the input button pressed
void buttonPressed(int button){
  /*
    Datas for managing the Bouncing Problem
  */
  static unsigned long last_interrupt_time = 0;
  unsigned long interrupt_time = millis();
  // If interrupts come faster than 200ms, assume it's a bounce and ignore
  if (interrupt_time - last_interrupt_time > 200) 
  {
    switch (controller->getStatus())
    {
      case INPUT_WAIT:
        if(button == 1){
          /*Manage the bouncing problem */
          if(abs(millis() - bounceTime) > BOUNCE_DURATION){
            bounceTime = millis();
            Serial.println("-> B1 is pressed, the game starts..");
            startGame();
          }
        }
        break;
      case DEEP_SLEEP:
        wakeUp();
        break;
      case GAME_START:
        controller->phasePenalty();
        break;
      case SHOW_PATTERN:
        controller->phasePenalty();
        break;
      case RECREATE_PATTERN:
        ledON(button);
        controller->userAddPosition(button-1);
      break;
    }
  }
  last_interrupt_time = interrupt_time;
}

void button_1_handler(){
  buttonPressed(1); 
}
void button_2_handler(){
  buttonPressed(2);
}
void button_3_handler(){
  buttonPressed(3);  
}
void button_4_handler(){
  buttonPressed(4);
}

void setup() {
  //Create the game controller, It will manage all the phase of the game
  controller = new GameController();
  //Fade datas
  currIntensity = 0;
  fadeAmount = 5;

  Serial.begin(32600);
  Serial.println("----- WELCOME TO THE CATCH LED PATTERN GAME, PRESS BUTTON 1 TO START THE GAME !!! -----");
  Serial.flush();

  /*--SET LEDS--*/
  pinMode(PIN_LED_1_GREEN, OUTPUT);
  pinMode(PIN_LED_2_GREEN, OUTPUT);
  pinMode(PIN_LED_3_GREEN, OUTPUT);
  pinMode(PIN_LED_4_GREEN, OUTPUT);
  pinMode(PIN_RED_LED, OUTPUT);
  /*--SET BUTTONS--*/
  pinMode(PIN_BUTTON_1, INPUT);
  pinMode(PIN_BUTTON_2, INPUT);
  pinMode(PIN_BUTTON_3, INPUT);
  pinMode(PIN_BUTTON_4, INPUT);
  /* */

  /*SLEEP MODE */
  Timer1.initialize(TEN_SECONDS_SLEEP);
  Timer1.attachInterrupt(deepSleep);

  /*MANAGE INTERRUPTS */
  enableInterrupt(PIN_BUTTON_1,button_1_handler,RISING);
  enableInterrupt(PIN_BUTTON_2,button_2_handler,RISING);
  enableInterrupt(PIN_BUTTON_3,button_3_handler,RISING);
  enableInterrupt(PIN_BUTTON_4,button_4_handler,RISING);
  
  /*GENERATE THE TIMER T2 AND T3*/
  controller->timerShowPattern();
  controller->timerBeginGame();
}

void leftToRight(int *leds){
  for(int i = 0; i < NLEDS; i++){
      if(i > 0 and i != NLED-1){
        digitalWrite(leds[i-1], LOW);
        digitalWrite(leds[i], HIGH);
      }else if(i == 0){
        digitalWrite(leds[i], HIGH);
        digitalWrite(leds[NLEDS-1], LOW);
      }else if(i == NLEDS-1){
        digitalWrite(leds[i], HIGH);
        digitalWrite(leds[0], LOW);
      }
      delay(250);

  }
}

void rightToLeft(int* leds){
  for(int i = NLEDS-1; i >= 0; i--){
      if(i > 0 and i != NLED-1){
        digitalWrite(leds[i+1], LOW);
        digitalWrite(leds[i], HIGH);
      }else if(i == 0){
        digitalWrite(leds[i], HIGH);
        digitalWrite(leds[i+1], LOW);
      }else if(i == NLEDS-1){
        digitalWrite(leds[i], HIGH);
        digitalWrite(leds[i-1], LOW);
      }
      delay(250);
  }
}

void rightAnswer(){
  allLedsOff();
  int leds[] = {PIN_LED_1_GREEN, PIN_LED_2_GREEN, PIN_LED_3_GREEN, PIN_LED_4_GREEN};
  for(int i = 0; i < 2; i++){
      leftToRight(leds);
      rightToLeft(leds);
  }
  allLedsOff();
}

void fade(){
    analogWrite(PIN_RED_LED, currIntensity);   
    currIntensity = currIntensity + fadeAmount;
    if (currIntensity == 0 || currIntensity == 255) {
      fadeAmount = -fadeAmount ; 
    }     
    delay(15); 
}

bool anyInteraction(){
  return digitalRead(PIN_BUTTON_1) == HIGH or
  digitalRead(PIN_BUTTON_2) == HIGH or
  digitalRead(PIN_BUTTON_3) == HIGH or
  digitalRead(PIN_BUTTON_4) == HIGH;
}

void loop() {
  switch (controller->getStatus())
  {
    case INPUT_WAIT:
      /*Fade of the red led*/
      fade();
      break;
    case PENALTY:
      //We enter in this case if the user commited a Penalty. 
      Serial.println("==> You click a button to early or you have chosen the wrong pattern, a penalty is assigned :( ");
      PENALTY_LINE
      allLedsOff();
      digitalWrite(PIN_RED_LED, HIGH);
      delay(1000);
      digitalWrite(PIN_RED_LED, LOW);
      controller->addPenalty();
      if(controller->isGameOver()){
        //Penalties == 3, the game must be over
        controller->phaseGameOver();
      }else{
        controller->phaseStartGame();
        timer_show_pattern = 0;
        continueGame();
      }
      break;
      case GAME_SCORE:
        if(controller->checkSequence()){

          Serial.println("--> Correct, you recreate the original pattern :) ");
          rightAnswer();
          controller->increaseScore();
          controller->timerReduceTimers();
          controller->phaseStartGame();
          continueGame();
        }else{
          if(controller->isGameOver()){
            controller->phaseGameOver();
          }else{
            controller->phasePenalty();
          }
        }        

        break;
      case GAME_OVER:
        Serial.print("::> The game is over, your score is ==> ");
        Serial.println(controller->getScore());
        SEPARATION_LINE
        allLedsOff();
        Timer1.detachInterrupt();
        Serial.flush();
        delay(TEN_SECONDS_DELAY);
        Serial.println("THE GAME STARTS AGAIN -> ");
        delay(50);
        controller->resetGame();
        startGame();
        break;
      case VOID:
      break;
  }
}